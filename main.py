import os
from flask import request
from flask_bootstrap import Bootstrap
from flask_dropzone import Dropzone
from flask import Flask, render_template
from malware_classification import dynamic_predict
from malware_classification import static_predict
import hashlib

app = Flask(__name__)
app.config['SECRET_KEY'] = 'Bianca'
bootstrap = Bootstrap(app)
dropzone = Dropzone()
dropzone.init_app(app)
# app.config['DROPZONE_REDIRECT_VIEW'] = 'result'
# upload_dir=os.path.join(os.getcwd(),'upload')
upload_dir=".\\upload\\"
if not os.path.exists(upload_dir):
    os.makedirs(upload_dir,mode=0o755)


#主页
@app.route('/', methods=['GET', 'POST'])
def index():
    return render_template('index.html')


def is_PE(fp):
    flag1 = fp.read(2) #读取文件前两个字节
    fp.seek(0x3c) #获取PE头偏移
    offset = ord(fp.read(1))
    fp.seek(offset)
    flag2 = fp.read(4) #获取PE头签名
    if flag1==b'MZ' and flag2==b'PE\x00\x00': #判断是否为PE文件的典型特征签名
        return 1
    else:
        return 0

def match(file, Bytes=1024):
        md5_1 = hashlib.md5()
        while 1:
            data = file.read(Bytes)
            if data:
                md5_1.update(data)
            else:
                break
        ret = md5_1.hexdigest()
        return ret

#上传文件,保存到指定路径
# files=[]#上传文件路径
global filepaths
filepaths=[]

@app.route('/upload', methods=['POST'])
def upload():
    global filepaths
    if request.method == 'POST':  # 如果请求类型为POST，说明是文件上传请求
        f = request.files.get('file')  # 获取文件对象
        f2=f
        if is_PE(f2)==0:
            return '上传格式仅限windows下可执行程序!', 400
        f.save(os.path.join(upload_dir, f.filename))  # 保存文件
        filepaths.append(os.path.join(upload_dir, f.filename))
    return render_template('index.html')  # 渲染上传页面

@app.route('/result_dynamic', methods=['GET','POST'])
def result_dynamic():
    results=[]
    for filepath in filepaths:
        re = dynamic_predict(filepath)
        results.append(re)
    return render_template('result.html',result = str(results))

@app.route('/result_static', methods=['GET','POST'])
def result_static():
    results=[]
    output=""
    for filepath in filepaths:
        re = static_predict(filepath)
        results.append(re)
    for i in results:
        if i==1:
            output="adware"
        elif i==2:
            output="backdoor"
        elif i==3:
            ouput="rootkit"
        elif i==4:
            output="spyware"
        elif i==5:
            output="trojan"
        elif i==6:
            output="worm"
        elif i==7:
            output="benign"

    return render_template('result.html',result = output)


if __name__ == '__main__':
    app.run(debug=True)
